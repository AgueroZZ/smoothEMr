% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_initialization.R
\name{initialize_smoothEM}
\alias{initialize_smoothEM}
\title{Initialize SmoothEM (single- or multi-scale)}
\usage{
initialize_smoothEM(
  X,
  method = c("tSNE", "PCA", "random", "multi_scale", "fiedler", "pcurve", "isomap"),
  rw_q = 2,
  lambda = 1,
  relative_lambda = TRUE,
  K = NULL,
  m_max = 6,
  num_iter = 1,
  modelName = "EEI",
  ridge = 0,
  nugget = 0,
  eigen_tol = NULL,
  keep_history = FALSE,
  include.data = TRUE,
  adaptive = TRUE,
  lambda_min = 1e-08,
  lambda_max = 1e+08,
  ...
)
}
\arguments{
\item{X}{Numeric matrix \code{(n x d)} of observations.}

\item{method}{Initialization method. If not \code{"multi_scale"}, it is passed to
\code{initialize_ordering()}. If \code{"multi_scale"}, a progressive coarse-to-fine
initialization is used via \code{progressive_smoothEM()}.}

\item{rw_q}{Integer random-walk order \code{q} for the separable RW penalty (default 2).}

\item{lambda}{Nonnegative penalty strength. For \code{method="multi_scale"}, this is
interpreted as \code{lambda_final}.}

\item{relative_lambda}{Logical; if TRUE, rescales the precision used for fitting/evaluation
by the current marginal variances (intended for EEI-like shared covariance across clusters).}

\item{K}{Integer number of grid points (used only when \code{method != "multi_scale"}).
If NULL, defaults to \code{min(50, floor(nrow(X)/5))} with minimum 2.}

\item{m_max}{Integer finest exponent for multi-scale grid; final grid size is
\code{K_final = 2^m_max + 1}.}

\item{num_iter}{Integer >= 1; total number of SmoothEM outer iterations to run.
Exactly one iteration is run in the warm-start step, and the remaining
\code{num_iter - 1} iterations (if any) are run by \code{do_smoothEM()}.}

\item{modelName}{Covariance model passed to \code{EM_algorithm()} / \code{MSTEP()}.
Common choices include \code{"VVV"}, \code{"VII"}, \code{"EII"}, \code{"EEI"}.}

\item{ridge}{Nonnegative ridge added in constructing the RW precision.}

\item{nugget}{Nonnegative diagonal jitter added to covariance estimates during fitting.}

\item{eigen_tol}{Optional tolerance passed to generalized log-determinant routines used
in objective/ELBO evaluation.}

\item{keep_history}{Logical; if TRUE and \code{method=="multi_scale"}, attach the full
progressive initialization result under \code{meta$init$details$progressive}.}

\item{include.data}{Logical; if TRUE, store the data matrix in the returned object.}

\item{adaptive}{Logical; if TRUE, estimate a starting \eqn{\lambda} from the initial
mean vector and enable adaptive updates during continuation via \code{do_smoothEM()}.}

\item{lambda_min, lambda_max}{Positive bounds used to clip the estimated/updated \eqn{\lambda}
when \code{adaptive=TRUE}.}

\item{...}{Extra arguments passed to \code{initialize_ordering()} (when
\code{method != "multi_scale"}), or to \code{progressive_smoothEM()} (when
\code{method == "multi_scale"}).}
}
\value{
A \code{smooth_em} object with fitted parameters, responsibilities, and traces.
  Initialization provenance is stored in \code{meta$init}, including \code{lambda_init_est}
  and \code{lambda_init_source} when \code{adaptive=TRUE}.
}
\description{
Creates a \code{smooth_em} object using a chosen initialization method and then runs
SmoothEM for a specified number of iterations.

The initialization is always "warm-started" by running exactly one outer EM iteration
(via \code{EM_algorithm(max_iter = 1)} for non-multi-scale; or \code{progressive_smoothEM(max_iter = 1)}
per stage for multi-scale). If \code{num_iter > 1}, the remaining iterations are completed
by \code{do_smoothEM()}, which enables features such as adaptive penalty updates.

When \code{adaptive = TRUE}, an initial \eqn{\lambda} is estimated ("profile-style") from
the current mean vector \eqn{u} (stacked \code{mu}) and the base precision \code{Q_base}:
\deqn{\lambda^\*(u) = r / (u^\top Q_\mathrm{base} u), \quad r = p - \mathrm{rank\_deficiency}}
where \eqn{p} is the dimension of \code{Q_base}. The estimated value is clipped to
\code{[lambda_min, lambda_max]} and used as the starting \eqn{\lambda}.
}
\examples{
\dontrun{
set.seed(1)
X <- matrix(rnorm(200 * 2), 200, 2)

# Fixed lambda
fit0 <- initialize_smoothEM(X, method = "PCA", num_iter = 10, adaptive = FALSE, lambda = 10)

# Adaptive lambda (estimate start + adapt during continuation)
fit1 <- initialize_smoothEM(X, method = "tSNE", num_iter = 10, adaptive = TRUE, lambda = 10)

# Multi-scale initialization
fit2 <- initialize_smoothEM(X, method = "multi_scale", m_max = 6, num_iter = 5, adaptive = TRUE)
}
}
