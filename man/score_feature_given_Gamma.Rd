% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/07_partition.R
\name{score_feature_given_Gamma}
\alias{score_feature_given_Gamma}
\title{Score a single feature given responsibilities (Gamma)}
\usage{
score_feature_given_Gamma(
  xj,
  Gamma,
  Q_K,
  rw_q = 0L,
  score_mode = c("ml", "none"),
  relative_lambda = TRUE,
  lambda_min = 1e-10,
  lambda_max = 1e+10,
  nugget = 0,
  optimize_lambda = NULL,
  lambda_init = 1,
  max_sigma_iter = 1L
)
}
\arguments{
\item{xj}{Numeric vector of length \code{n} (one feature).}

\item{Gamma}{Numeric matrix \code{(n x K)} of responsibilities.}

\item{Q_K}{Numeric matrix \code{(K x K)}; base RW precision (lambda=1).}

\item{rw_q}{Integer \eqn{\ge 0}. Rank deficiency along K (RW order).}

\item{score_mode}{One of \code{"ml"} or \code{"none"}.}

\item{relative_lambda}{Logical; if TRUE use \eqn{Q_{base} = Q_K / \sigma_j^2} (homoskedastic scaling).}

\item{lambda_min, lambda_max}{Positive bounds for \eqn{\lambda} when \code{score_mode="ml"}.}

\item{nugget}{Nonnegative scalar added to \eqn{\sigma_j^2}.}

\item{optimize_lambda}{Logical or NULL. If NULL, defaults to TRUE for \code{"ml"} and FALSE for \code{"none"}.}

\item{lambda_init}{Positive scalar. Fixed \eqn{\lambda} when \code{score_mode="none"} (default 1),
and initial value if \code{optimize_lambda=FALSE}.}

\item{max_sigma_iter}{Integer \eqn{\ge 1}. Number of (lambda -> mu -> sigma2) refresh steps.}
}
\value{
A list with components:
\itemize{
  \item \code{score}: scalar score for feature \eqn{j}.
  \item \code{lambda}: fitted (or fixed) \eqn{\lambda_j}.
  \item \code{sigma2}: fitted \eqn{\sigma_j^2}.
  \item \code{mu_vec}: numeric vector length K of \eqn{\hat\mu_{j\cdot}}.
  \item \code{logdetA}: scalar \eqn{\log|A_j|} (only meaningful for \code{"ml"}; still returned).
}
}
\description{
Computes an alignment score for a single feature \eqn{x_j} under a fixed responsibilities
matrix \eqn{\Gamma \in \mathbb{R}^{n\times K}}. The score is used for greedy feature
partitioning into multiple latent orderings.

Two score modes are supported:
\describe{
  \item{\code{score_mode = "none"}}{
    Plug-in (ELBO/Q-like) score. The smoothing parameter \eqn{\lambda} is fixed at
    \code{lambda_init} (default 1). The score depends on the MAP component means
    \eqn{\hat\mu_{j\cdot}} via the weighted SSE.
  }
  \item{\code{score_mode = "ml"}}{
    Collapsed (marginal-like) score: plug-in score plus the Laplace curvature correction
    \eqn{+\frac{K}{2}\log(2\pi) - \frac12\log|A_j|}. In this mode, \eqn{\lambda} is optimized
    by 1D maximization over \eqn{\log \lambda \in [\log(\text{lambda_min}),\log(\text{lambda_max})]}.
  }
}

The fitted 1D quantities \eqn{\hat\mu_{j\cdot}} and \eqn{\hat\sigma_j^2} are returned and can be
appended to a partition's csmooth-style parameters during greedy growth.
}
\seealso{
\code{\link{score_one_coord_csmooth}}, \code{\link{forward_two_ordering_partition_csmooth}}
}
