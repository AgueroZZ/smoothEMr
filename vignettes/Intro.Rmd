---
title: "Intro to smoothEMr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(smoothEMr)
```

We will simulate some data from a spiral embedded in 2D space, and then fit a smoothEM model to it.

```{r}
simulate_swiss_roll_1d_2d <- function(n = 800,
                                     t_range = c(1.5 * pi, 6 * pi),
                                     sigma = 0.15,     # can be scalar or length-2
                                     seed = 1) {
  stopifnot(length(t_range) == 2)
  stopifnot(length(sigma) == 1 || length(sigma) == 2)

  set.seed(seed)

  # 1D parameter
  t <- runif(n, min = t_range[1], max = t_range[2])

  # true 2D "swiss roll" (spiral)
  x_true <- t * cos(t)
  y_true <- t * sin(t)

  # noise
  if (length(sigma) == 1) sigma <- rep(sigma, 2)
  x_obs <- x_true + rnorm(n, 0, sigma[1])
  y_obs <- y_true + rnorm(n, 0, sigma[2])

  list(
    t = t,
    truth = data.frame(x = x_true, y = y_true),
    obs   = data.frame(x = x_obs,  y = y_obs)
  )
}

sim <- simulate_swiss_roll_1d_2d(n = 1500, sigma = 0.2, seed = 123)

plot(sim$obs$x, sim$obs$y, pch = 16, cex = 0.35, col = "grey80",
     xlab = "x", ylab = "y", main = "Noisy 2D swiss-roll (spiral)")
pal <- colorRampPalette(c("navy", "cyan", "yellow", "red"))(256)
t_scaled <- (sim$t - min(sim$t)) / (max(sim$t) - min(sim$t))  # in [0,1]
col_t <- pal[pmax(1, pmin(256, 1 + floor(255 * t_scaled)))]
points(sim$truth$x, sim$truth$y, pch = 16, cex = 0.25, col = col_t)
```

Now we fit a smoothEM model to the noisy observations.

```{r}
# initialize using tSNE
fit <- initialize_smoothEM(X = as.matrix(sim$obs), method = "tSNE", adaptive = FALSE)

# run 10 iterations of smoothEM
fit <- fit |>
  do_smoothEM(iter = 30, adaptive = FALSE)

# plot results
plot(fit)
plot(fit, plot_type = "elbo")
```


We could also try other initialization methods, such as PCA or Fiedler vector initialization.

```{r}
fit_pca <- initialize_smoothEM(X = as.matrix(sim$obs), method = "PCA",  adaptive = FALSE) |>
  do_smoothEM(iter = 50, adaptive = FALSE)
plot(fit_pca)

fit_fiedler <- initialize_smoothEM(X = as.matrix(sim$obs), method = "fiedler", adaptive = FALSE) |>
  do_smoothEM(iter = 50, adaptive = FALSE)
plot(fit_fiedler)
```


To automatically select the best initialization method, we can use:

```{r}
best <- optimize_initial(
  as.matrix(sim$obs),
  num_iter = 5,
  num_cores = 6,
  m_max = 6,
  two_panel = FALSE,
  adaptive = FALSE,
  plot = TRUE
)

plot(best, plot_type = "scatterplot", dims = c(1,2))

best_fit <- best |>
  do_smoothEM(iter = 50, adaptive = FALSE)

plot(best_fit)
```


If we choose a different choice of `num_cores`, we could end up with a different optimal initialization:

```{r}
best_2 <- optimize_initial(
  as.matrix(sim$obs),
  num_iter = 30,
  num_cores = 6,
  m_max = 6,
  two_panel = FALSE,
  adaptive = FALSE,
  plot = TRUE
)

plot(best_2, plot_type = "scatterplot", dims = c(1,2))
```

Another important parameter to tune is the smoothing parameter `lambda`, which can lead to very different results:

```{r}
best_lambda <- optimize_initial(
  as.matrix(sim$obs),
  num_iter = 30,
  num_cores = 6,
  lambda = 11,
  m_max = 6,
  two_panel = FALSE,
  adaptive = FALSE,
  plot = TRUE
)

plot(best_lambda, plot_type = "scatterplot", dims = c(1,2))
```


Compare the optimized ELBO values for different lambda values:

```{r}
lambda_vec <- seq(9, 11, length.out = 20)
elbo_vals <- sapply(lambda_vec, function(lam) {
  fit_lam <- initialize_smoothEM(
    X = as.matrix(sim$obs),
    method = "fiedler",
    K = 65,
    lambda = lam,
    adaptive = FALSE
  ) |>
    do_smoothEM(iter = 30, adaptive = FALSE)
  fit_lam$elbo[length(fit_lam$elbo)]
})
plot(lambda_vec, elbo_vals, type = "b", pch = 16,
     xlab = expression(lambda), ylab = "Optimized ELBO",
     main = "Effect of Smoothing Parameter on ELBO")
```

A more "adaptive" fitting procedure involves updating the smoothing parameter `lambda` at each iteration based on the current $\hat{U}$ estimate:
\[
\hat{\lambda}^{(i)} = \arg\max_{\lambda} ELBO(\hat{U}^{(i)}, \lambda^{(i-1)}).
\]

```{r}
fit_adaptive <- initialize_smoothEM(X = as.matrix(sim$obs), method = "fiedler", adaptive = TRUE) |>
  do_smoothEM(iter = 30, adaptive = TRUE)
plot(fit_adaptive)
```




