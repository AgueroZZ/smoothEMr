---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# smoothEMr

<!-- badges: start -->
<!-- badges: end -->

The goal of `smoothEMr` is to efficiently implement the SmoothEM algorithm for various GMRF priors, using different initialization strategies.

## Installation

You can install the development version of `smoothEMr` like so:

``` r
pak::pak("AgueroZZ/smoothEMr")
```

## Example

This is a basic example which shows you how to solve a common problem:

```{r setup}
library(smoothEMr)
```

We will simulate some data from a spiral embedded in 2D space, and then fit a smoothEM model to it.

```{r}
# sim <- simulate_swiss_roll_1d_2d(n = 1500, sigma = 0.2, seed = 123)
sim <- simulate_spiral2d(n = 1500, turns = 1, noise = 0.1, seed = 123)
plot(sim$obs, pch = 16, cex = 0.35, col = "grey80",
     xlab = "x1", ylab = "x2", main = "Noisy 2D spiral")

# plot(sim$obs$x, sim$obs$y, pch = 16, cex = 0.35, col = "grey80",
#      xlab = "x", ylab = "y", main = "Noisy 2D swiss-roll (spiral)")
# pal <- colorRampPalette(c("navy", "cyan", "yellow", "red"))(256)
# t_scaled <- (sim$t - min(sim$t)) / (max(sim$t) - min(sim$t))  # in [0,1]
# col_t <- pal[pmax(1, pmin(256, 1 + floor(255 * t_scaled)))]
# points(sim$truth$x, sim$truth$y, pch = 16, cex = 0.25, col = col_t)
```

Now we fit a smoothEM model to the noisy observations.

```{r}
set.seed(123)
# initialize using tSNE
fit <- initialize_csmoothEM(X = as.matrix(sim$obs), method = "tSNE", adaptive = FALSE)

fit <- fit |>
  do_csmoothEM(iter = 100, adaptive = "ml")

# plot results
plot(fit)
plot(fit, plot_type = "elbo")
plot(fit$ml_trace, type = 'o')
```


We could also try other initialization methods, such as PCA or Fiedler vector initialization.

```{r}
fit_pca <- initialize_csmoothEM(X = as.matrix(sim$obs), 
                                method = "PCA",
                                adaptive = FALSE)
fit_pca <- fit_pca |> do_csmoothEM(iter = 100, adaptive = "ml")
plot(fit_pca)

fit_fiedler <- initialize_csmoothEM(X = as.matrix(sim$obs), 
                                    adaptive = "ml",
                                    method = "fiedler") |>
  do_csmoothEM(iter = 30, adaptive = "ml")
plot(fit_fiedler$ml_trace)
plot(fit_fiedler)
```


To automatically select the best initialization method, we can use:

```{r}
best <- optimize_initial_csmoothEM(
  as.matrix(sim$obs),
  num_iter = 5,
  num_cores = 6,
  two_panel = FALSE,
  plot = TRUE
)

plot(best, plot_type = "scatterplot", dims = c(1,2))

best_fit <- best |>
  do_csmoothEM(iter = 50)

plot(best_fit)
```


If we choose a different choice of `num_iter`, we could end up with a different optimal initialization:

```{r}
best_2 <- optimize_initial_csmoothEM(
  as.matrix(sim$obs),
  num_iter = 30,
  num_cores = 6,
  two_panel = FALSE,
  plot = TRUE
)

plot(best_2, plot_type = "scatterplot", dims = c(1,2))
```

